<html>
<head>
<link href="css/question.css" type="text/css" rel="stylesheet" />
<title>Filter Description</title>
</head>
<body>
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<h1>
					Welcome To Filters <br><br>
					<code>Operations with Images</code>
				</h1>
				<div id="page1">
					<h2>Description</h2>
					<p>
                        In this project, I wrote a Python program to make some calculations on 3D pixels of some images.<br>
                        I used the <b>ppm</b> image format for reading image files. I declared two functions: <br>
						<ol>
						  <li><code>read_ppm_file(f)</code> which will enable you to read .ppm files to a 3d list.</li>
						  <li><code>img_printer(img)</code> which is a function that prints 3d lists in a readable manner.</li>
						</ol>
						Two of the inputs you need are taken for you, <code>filename</code> and <code>operation</code>. <br>
						filename is the name of the .ppm file you will read, and operation is a specific operation which you will apply to the image you read. <br>
						The rest of the inputs you take will depend on the operation. filename will always belong to files in src folder, so you can directly use them with the filename variable. <br>
						operation will always be an integer between 1-7, both inclusive. The details of the operations are as follows:
					</p>
					<h4>operation == 1</h4>
					<p>
						When operation input is 1, min-max normalization will be applied. <br>
						In this case you will require two additional inputs: <code>minimum</code> and <code>maximum</code>. <br>
						Each input will be given in separate lines. These two values should be integers. <br>

						The formula for min-max normalization is as follows:
						<p>
							<img src="imgs/minmax_norm.png" alt="Min-Max Normalization Formula">
						</p>
						
					</p>

					<h4>operation == 2</h4>
					<p>
						When operation input is 2, z-score normalization will be applied . <br>
						This case does not require additional inputs. You will find <b>channelwise</b> means and standard deviations, and output the normalized image. <br>
						The required formulas are provided below:
						<p>
							<img src="imgs/zscore_norm.png" alt="Z-Score Normalization Formulas">
						</p>
					</p>
					<h4>operation == 3</h4>
					<p>
						When operation input is 3, the image will be converted to black and white. This case does not require additional inputs. <br>
						This can easily be done by taking the average of each pixel's channel values, and assigning to each channel the average value.<br>
						For example, if a pixel's channel values are [12, 13, 14], I did (12 + 13 + 14) / 3 = 13 and assigned to that pixel's channels [13, 13, 13] and that's it.
					</p>
					<h4>operation == 4</h4>
					<p>
						When operation input is 4, convolution is applied to the image.<br>
						You will be provided two additional inputs: one is the filename of a filter which will be located under the src folder <br>
						and the other is a stride parameter which denotes how many steps the filter will move after each summation is complete. <br>
						<b>Important:</b> If the weighted sum exceeds the image maximum color value or becomes less than 0, value is clipped such that it is always between 0 and maximum color value. <br>
						Each input will be given in separate lines. An example of the operation is provided below where stride is 1:
						<p>
							<img src="imgs/convolution.png" alt="Convolution Example">
						</p>
					</p>
					<h4>operation == 5</h4>
					<p>
						When operation input is 5, convolution is again applied to the image, but this time I <br>
						padded zeros to the edges of your input image so that your output image has the same dimensions as your input image. <br>
						You will once more be provided two additional inputs: one is the filename of a filter which will be located under the src folder <br>
						and the other is a stride parameter which denotes how many steps the filter will move after each summation is complete. <br>
						<b>Important:</b> If the weighted sum exceeds the image maximum color value or becomes less than 0, value is clipped such that it is always between 0 and maximum color value. <br>
						Each input will be given in separate lines.
					</p>
					<h4>operation == 6</h4>
					<p>
						When operation input is 6, color quantization is applied to the image. <br>
						You will get a range input which you will use to compare whether two <b>pixels</b> are similar enough to be grouped together or not. Input will be given in a separate line.<br>
						The rule for this quantization is simple, if <b>all</b> the channel values between two pixels differ by less than the range, then they will be made equal. <br>

					</p>
					<h4>operation == 7</h4>
					<p>
						When operation input is 7, color quantization is again applied to the image but this time it is a 3d quantization. <br>
						You will provide a range input which I used to compare whether two <b>channel values</b> are similar enough to be grouped together or not. <br>
						The rule for this quantization is if the channel values between two neighbours differ by less than the range, then they will be made equal. <br>
						This time, different channels of the same pixel are considered as neighbors as well as the same channel on different pixels.
					</p>

				</div>
			</div>
		</div>
	</div>
</body>
</html>
